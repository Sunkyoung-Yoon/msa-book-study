## 1.1 마이크로 서비스 아키텍처로 진화
담당자: 윤선경
</br>
</br>
</br>


소프트웨어 아키텍처는 소프트웨어 구성 요소 간 구조, 동작, 상호 작용을 하는 모든 기초 부분과 관련된다.
### 1.1.1 N-계층 아키텍처
N-계층 아키텍처(다계층 아키텍처)는 UI, 서비스, 데이터, 테스팅 등 고유의 책임과 기능이 있는 여러 계층으로 나뉜다.

-> 전체 애플리케이션을 만드는 데 여러 애플리케이션이 결합되는 형태(UI를 위한 프로젝트나 솔루션 + 서비스를 위한 프로젝트나 솔루션 +..등)

* 대규모 엔터프라이즈 시스템의 경우

|장점|
|:---|
|1. 관심사도 잘 분리되어 있다. -> UI, 데이터, 비즈니스 로직 같은 영역 따로 고려 가능|
|2. 팀이 애플리케이션의 여러 컴포넌트에서 독립적으로 작업하기 쉬움|
|3. 널리 알려진 아키텍처로 숙련된 개발자를 찾기가 비교적 수월함|

|단점|
|:---|
|1. 변경 시 전체 애플리케이션 중지해야함|
|2. 메세지가 상하 전체 계층에 통행 -> 비효율적|
|3. 대규모라면 배포후 리택터링 어려울 수 있음|
</br>

### 1.1.2 모놀리스 아키텍처
모놀리식 아키텍처는 모든 UI, 비즈니스 및 데이터베이스 액세스 로직은 함께 고유한 애플리케이션으로 패키징되어 서버에 배포된다.
-> 모든 코드가 단일 유닉으로 빌드, 테스트, 배포되어야 함 -> 개발 팀들은 배포 일을 모두 맞춰야 한다.

애플리케이션은 단일 작업으로도 배포가 가능하지만 보통 한 애플리케이션에서는 여러 개발 팀이 있다.
|장점|
|:---|
|1. N-계층 이나 마이크로서비스에 비해 복잡하지 않고 구축 및 배포도 더 쉬움|
|2. 사용하는 사람들이 많아 관련 사례가 잘 정리되어 있음|

|단점|
|:---|
|모놀리스에 대한 모든 변경이 애플리케이션의 다른 부분까지 영향을 둘 수 있음|
|변경될 가능성을 줄이기 위해 많은 시간과 비용이 소모된다.|

위 단점때문에 유연함과 유지 보수 이점을 더 많이 제공하는 마이크로서비스 아키텍처 사용이 점점 증가하고 있다.

</br>

### 1.1.3 마이크로 서비스란
마이크로서비스는 작고 느슨하게 결합된 분산 서비스를 의미한다.
이를 사용하면 대규모 어플리케이션을 잘 정의된 작은 조각(책임이 명확하고 관리하기 쉬운 구성 요소)로 분해해서 
대규모 코드베이스에서 발생하는 전통적인 복잡성 문제를 해결할 수 있다.
|특징|
|:---|
|1. 애플리케이션 로직은 명확하고 대등한 책임 경계가 있는 작은 컴포넌트로 분해|
|2. 각 구성 요소는 작은 책임 영역을 담당하고 서로 독립적으로 배포|
|3. HTTP와 JSON 같은 경량의 프로토콜 사용(서비스 소비자와 공급자간 데이터 교환을 위해)|
|4. 마이크로서비스 방식으로 구축하면 다양한 언어와 기술로 구현 가능|
|5. 조직은 팀을 더 작게 만들어 명확한 책임 부여 가능|

<img src="https://user-images.githubusercontent.com/97610532/233786355-9cba514a-ae69-414a-a8a1-fc84e075a4da.png" width="600px" height="400px"/>

* **모놀리식 아키텍처**
  * 서비스들이 동일한 애플리케이션 안에 있다.
* **마이크로서비스 아키텍처**
  * 서비스는 분리되어 있고, 각 서비스는 특정 데이터에 액세스 계층을 갖고 공통 또는 개별 데이터베이스 사용 (위 그림에서는 공통 데이터베이스) 

</br>

### 1.1.4 애플리케이션 구축 방법을 왜 바꾸어야 할까?
오늘날 애플리케이션 구축
| 상황 | 설명                            |
| -------------------------------------- | ---------------------------------------------- |
| 복잡성증가                             | 사내 데이터 센터 뿐만 아니라 외부 인터넷 서비스 제공자에 있는 다양한 서비스와 데이터베이스 통신 필요|
| 고객은 더 빠른 전달을 원함              | 소프트웨어패키지 릴리스를 다음해까지 기다리기(x) -> 소프트웨어 제품 기능을 분리 및 제공하여 새로운 기능이 몇주(빠르면 며칠)내 릴리스 원함|
| 고객 또한 안정적인 성능과 확장성 요구   |트랜잭션에 따라 많은 서버를 신속하고 매끄럽게 확장 및 축소해야함(글로벌 애플리케이션은 시간별 트랜잭션 양 예측이 어렵기 때문)|
|고객은 애플리케이션을 언제든 사용하길 원함|애플리케이션의 회복성이 높아야 함 -> 한 부분의 고장이나 문제가 전체로 확장되지 않아야 한다.|
</br>

위 기대를 충족하기 위해 **개발자는 애플리케이션을 더 작은 서비스로 분리하고 단일 모놀리식 산출물에서 서비스 산출을 추출할 필요가 있다.**

| 요구사항        | 설명                                   |
| --------------- | ---------------------------------------------- |
|유연성(flexible) | 분리된 서비스는 새로운 기능을 신속하게 제공하도록 구성 (의존성이 낮은 코드일수록 코드 변경에 따른 복잡도가 낮아지고 코드의 테스 및 배포시간도 감소)|
|회복성(resilient)| 분리된 서비스는 애플리케이션의 한 부분의 문제가 전체로 확장x (고장은 전체로 촥장되기전에 억제되고 회복불능의 에러인 경우에는 애플리케이션이 원만하게 저하되도록 함) |
|확장성(scalable) |분리된 서비스는 여러 서비스에 쉽게 수평 분산 가능 -> 기능과 서비스 적절한 확장 가능|

모놀리식 애플리케이션의 확장성: 모든 로직이 얽혀있어 일부분만 병목 현상이 발생해도 전제 애플리케이션을 축소해야한다.

**마이크로서비스**
-> 작고(small), 단순하고(simple), 분리된(decouped) 서비스 = 확장 가능하고(scalable), 회복적이며(resilient) 유연한(flexible) 애플리케이션
</br>
