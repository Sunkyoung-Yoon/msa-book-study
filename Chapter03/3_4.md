# 3.4 데브옵스 이야기 : 혹독한 런타임 구축

담당자: 박희선
</br>
</br>
</br>

## 마이크로서비스 개발 4가지 원칙

- 마이크로서비스는 일체형이어야 한다
  - 하나의 소프트웨어 산출물로 시작 및 종료할 수 있는 서비스의 여러 인스턴스를 독립적으로 배포할 수 있어야 함
- 마이크로서비스는 구성 가능해야 한다
  - 서비스 인스턴스가 시작하면 필요한 구성 정보를 한곳에서 읽어 오거나 환경 변수로 전달받아야 함
  - 서비스 구성 정보를 설정하는 데 사람의 개입이 없어야 함
- 마이크로서비스 인스턴스는 클라이언트에 투명해야 한다
  - 클라이언트는 서비스의 정확한 위치를 알고 있어서는 안 된다
  - 그 대신 애플리케이션이 마이크로서비스 인스턴스의 물리적 위치를 몰라도 인스턴스 위치를 찾을 수 있도록 마이크로서비스 클라이언트는 _서비스 디스커버리 에이전트_ 와 통신해야 한다
- 마이크로서비스는 자기 상태를 전달해야 한다
  - 마이크로서비스 인스턴스는 고장 날 수 있으며 디스커버리 에이전트는 _고장난 인스턴스를 우회_ 해서 라우팅 해야 함

## 역설

> 이 네 가지 원칙은 마이크로서비스 개발에서 존재할 수 있는 역설을 드러냄 </br>

- 마이크로서비스는 크기와 범위가 작지만 분산되어 있음
- 자체 컨테이너에서 독립적으로 실행되므로 애플리케이션에 구동하는 부품은 많아짐

데브옵스 관점에서 마이크로서비스와 관련된 운영상 요구 사항을 사전에 해결하고, 이러한 네 가지 원칙을 마이크로서비스를 빌드하고 환경에 배포할 때마다 발생하는 표준 수명 주기 이벤트로 변환해야 함

## 마이크로서비스의 운영 수명 주기

### 1. 서비스 조립 : 마이크로서비스의 패키징과 배포

> 동일한 서비스 코드와 런타임이 정확히 동일한 방식으로 배포되도록 **_반복성과 일관성_**을 보장하면서 서비스를 패키징하고 배포하는 법

- 데브옵스 관점에서 마이크로서비스 아키텍쳐 핵심 개념은 애플리케이션의 _환경변화_ 에 대응하여 마이크로서비스의 많은 인스턴스를 신속히 배포할 수 있다는 것 </br>
  👉 이를 위해 마이크로서비스는 정리된 모든 의존성을 포함한 단일 산출물로 패키징되고 설치될 수 있어야 함
- 서비스 조립 단계에서 소스 코드를 컴파일 하고 런타임 엔진과 함께 패키징한다
  - 거의 모든 자바 마이크로서비스 프레임워크는 코드와 함께 패키징하고 배포할 수 있는 런타임 엔진 포함 (ex. tomcat -> JAR 실행 파일 빌드)
  - 전통적인 자바 웹 애플리케이션에서 애플리케이션은 애플리케이션 서버에 배포된다
  - 애플리케이션 서버의 구성을 애플리케이션과 분리하면 배포 과정에서 문제점이 발생되는데 이것은 많은 조직에서 애플리케이션 서버의 구성 정보를 소스 제어 저장소에서 관리하지 않고 사용자 인터페이스나 자체 관리 스크립트로 관리하기 때문 </br>
    👉 애플리케이션 서버 환경에서 **_구성 불일치_** 가 너무 쉽게 발생되어 표면적으로 무작위 장애를 갑자기 일으킴

### 2. 서비스 부트스트래핑 : 마이크로서비스의 구성 관리

> 마이크로서비스를 사람의 개입 없이 모든 환경에서 빠르게 시작하고 배포할 수 있도록 런타임코드에서 애플리케이션 코드와 환경별 구성코드를 분리하는 방법

서비스 부트스트래핑은 마이크로서비스가 처음 시작하고 애플리케이션 구성 정보를 로드할 때 일어남 </br>

- 구성 정보 저장소 : 이상적으로 구성 정보 저장소는 모든 구성 변경 사항을 버전 관리 가능하고, 누가 구성 데이터를 마지막으로 변경했는지 감독할 수 있어야 함
- 서비스 인스턴스 시작 : 서비스의 구성 정보가 변경되면 이전 구성으로 실행되는 서비스를 종료하거나 새 구성 정보를 다시 읽어 오도록 서비스에 전달한다
- 마이크로서비스가 시작할 때 환경별 정보나 애플리케이션 구성 정보 데이터는 다음과 같이 전달됨
  - 시작하는 서비스의 환경 변수로 전달하기
  - 중앙에서 관리되는 구성 저장소에서 읽어 오기

애플리케이션의 런타임 동작을 구성 가능하게 만들어야 할 때

- 애플리케이션과 함께 배포된 프로퍼티 파일에서 구성 데이터 읽기
- 관계형 데이터베이스 같은 데이터 저장소에서 데이터 읽어오기

마이크로서비스는 대개 동일한 종류의 구성을 요구한다 </br>

클라우드 마이크로서비스 애플리케이션은 수백 또는 수천 개의 마이크로서비스가 실행될 수 있으며 서비스가 전 세계로 확장되면 지리적으로 분산된 서비스 수가 많아짐 👉 새로운 구성 데이터를 가져오기 위해 서비스를 재배포하는 일은 수행하기 어려움

- 서비스 외부의 데이터 저장소에 데이터를 저장하면 이 문제가 해결되지만 클라우드 마이크로서비스 상황에서는 몇 가지 고유한 난제가 있다

### 클라우드 마이크로서비스의 고유한 난제들

- 구성 데이터는 구조가 단순한 편이라서 보통 자주 읽고 간혹 쓴다, 관계형 데이터베이스는 단순한 키-값 조합보다 훨씬 더 복잡한 데이터 모델을 관리하는 용도로 설계되었기 때문에 이 상황에서는 과분함
- 데이터는 정기적으로 액세스되지만 드물게 변경되므로 데이터의 읽기 지연 시간은 낮아야 함
- 데이터 저장소는 고가용성을 유지하고 데이터를 읽는 서비스에 가꿔야 함, 구성 데이터 저장소는 애플리케이션의 단일 장애 지점이기 때문에 완전히 다운되면 안 됨

### 3. 서비스 등록과 디스커버리 : 클라이언트가 마이크로서비스와 통신하는 방법

> 새 마이크로서비스 인스턴스가 배포될 때 애플리케이션 클라이언트가 새 서비스 인스턴스를 발견할 수 있는 방법

마이크로서비스 소비자 관점에서 마이크로서비스는 위치 투명성을 가져야 함 </br>
클라우드 기반 환경에서는 서버는 일시적이기 때문 </br></br>
🗯 일시적 ? </br>
서비스를 호스팅하는 서버가 일반적으로 기업 데이터 센터에 실행되는 서비스보다 수명이 짧다는 것 의미 </br></br>
클라우드 기반 서비스는 자기 서버에 완전히 새로운 IP 주소를 할당받아 신속하게 시작되고 종료될 수 있음 </br></br>
모든 서비스에는 고유하고 비영구적인 IP 주소가 할당되어 있음 </br>
**일시적** 서비스의 단점은 끊임없이 서비스 시작과 종료를 반복하는 상황에서 대규모 서비스를 수동 또는 직접 관리하면서 **_장애를 초래_** 할 수 있다는 것 </br>

마이크로서비스 인스턴스는 제삼자 에이전트에 자신을 등록해야 하는데, 이 등록과정을 **_디스커버리_** 라고 함 </br>
마이크로서비스 인스턴스가 서비스 디스커버리 에이전트에 등록될 때 인스턴스는 두 가지 정보 제공

- 물리적 IP 주소 (또는 서비스 인스턴스의 도메인 주소)
- 애플리케이션이 서비스를 찾을 때 사용되는 논리적 이름

특정 서비스 디스커버리 에이전트의 경우 상태 확인을 수행하는데 사용할 호출 가능한 URL을 등록할 때 서비스에 요구하기도 함 </br>
서비스 클라이언트는 디스커버리 에이전트와 통신하여 서비스 위치 찾음 = 서비스 클라이언트는 서비스 인스턴스의 물리적 위치를 알지 못하며, 그 대신 정상 서비스 인스턴스 위치를 디스커버리 에이전트에 물어본다

### 4. 서비스 모니터링 : 마이크로서비스의 상태 전달

> 마이크로서비스의 여러 인스턴스를 모니터링해야 하며 장애가 발생한 서비스 인스턴스를 우회해서 라우팅하고 종료되는지 확인

서비스 디스커버리 에이전트가 등록된 각 서비스 인스턴스 상태를 모니터링하고 라우팅 테이블에서 실패한 서비 인스턴스를 제거하여 클라이언트가 실패한 서비스 인스턴스와 통신하지 않도록 함 </br></br>
마이크로서비스가 시작된 후 서비스 디스커버리 에이전트는 해당 서비스가 가용한지 확인하고자 지속적으로 **_모니터링 하고 상태 확인 인터페이스를 핑_** 한다 </br>

REST 를 사용하는 마이크로서비스 환경에서 상태 확인 인터페이스를 만드는 가장 단순한 방법은 JSON 페이로드와 HTTP 상태 코드를 응답하는 HTTP 엔드포인트를 노출하는 것 </br>

스프링 부트에서는 엔드포인트를 노출하기가 어렵지 않으며, 스프링 액추에이터 모듈을 포함하도록 메이븐 빌드 파일만 수정하면 됨 </br>
스프링 액추에이터는 서비스 상태를 이해하고 관리할 수 있게 하며, 추가 설치 없이 바로 운영 가능한 엔드포인트 제공 </br>
🤞 p134-136 참고 </br>
