# 3.1 아키텍트 이야기: 마이크로서비스 아키텍처 설계
담당자: 윤선경
</br>
</br>
</br>



성공적인 마이크로 서비스 아키텍처를 구축하는 방법은 소프트웨어 개발 조직 내에 여러 개인의 관점을 통합시키는 것과 관련이 있다.
다음 세가지 역할이 가장 중요!
1. 아키텍트: 큰 크림을 염두에 두고 애플리케이션을 개별 마이크로서비스로 분해한 후 마이크로서비스가 솔루션을 제공하기 위한 상호작용 방식을 이해한다.
2. 소프트웨어 개발자: 코드 작성 및 언어와 개발 프레임워크를 사용하여 마이크로 서비스를 제공하는 방법을 이해한다.
3. 데브옵스: 운영 및 비운영 환경에 서비스 배포 및 관리 방법 결정
자세한 설명은 p98 참고
</br>
</br>


**아키텍트**
>  작동 모델(Working model)을 제공하는 것 (애플리케이션의 각 부분이 잘 조립되도록 개발자가 작성할 코드에 대한 스캐폴드(scaffold) 제공)
핵심 업무
1. 비즈니스 문제 분해
2. 서비스 세분화 확정
3. 서비스 인터페이스 정의 </br>

:question: 스캐폴드: 원래 건축에서 유래된 용어(건물 내외벽에 작업자가 지나다닐 수 있도록 만든 임시 구조물)로 초기 프로젝트의 뼈대를 만드는 기술 또는 MVC 프레임워크에서 DB액세스와 관련된 코드 생성 기술
</br>
</br>
</br>

## 3.1.1 비지니스 문제 분해
> 아키텍트는 비즈니스 문제를 각 활동 영역을 대표하는 덩어리로 분해하고 비즈니스 영역의 특정 부분과 연관된 비즈니스 규칙과 데이터 로직을 이 덩어리 안에 은닉한다.
* ex) 코드로 수행될 비즈니스 흐름을 보고 고객과 제품 정보 모두 필요함을 인식한다.</br>

⭐ 2개의 개별 데이터 영역 존재(= 다수의 마이크로서비스 동작 가능하다는 징조) -> 2개의 다른 비즈니스 트랜잭션이 교류하는 방식이 보통 마이크로서비스의 서비스 인터페이스가 된다.
</br>
</br>

**마이크로서비스로 분해시 사용할 지침**
|지침|설명|
|:--|:--|
|비즈니스 문제를 기술하는 데 사용된 명사(nouns)에 주목하라|* 문제를 기술하는 데 동일한 명사가 반복된다면 핵심 비즈니스 영역과 마이크로서비스의 기회를 나타내는 좋은 징후</br> * ex) 2장에서의 O-stock 애플리케이션에 대한 대상 명사의 예 -> 계약, 라이선스, 자산|
|동사(verb)에 주목하라|* 동사는 행동을 강조하고 종종 문제가 무엇인지를 드러나게 한다.</br> * ex) O-stack 애플리케이션의 적용하면 "데스크톱 서비스 부서의 마이크가 새로운 pc 셋업 시 소프트웨어 X에 대하 라이선스 수를 조회하고 여분이 있다면 X를 설치한다.  -> 핵심 동사는 조회하다, 업데이트하다.|
|데이터 응집성(cohesion)을 찾아라|* 비즈니스 문제를 개별 부분으로 나눌 때 서로 연관성이 높은 데이터 부분을 찾아야 한다.</br> * 통신 중 갑자기 논의한 것과 다른 데이터를 읽고 업데이트 한다면 또 다른 서비스 후보 등장 -> 새로운 서비스 후보 등장(마이크로서비스는 온전히 자기 데이터를 가져야 함)|
</br>

O-stack 사용자 및 이해관계 인터뷰 p101 참고
* 엠마가 관리하는 계약 정보을 어디에 저장할 것인가?
* 라이선스 정보는 어디에 저장하고 어떻게 관리할 것 인가?
* 제니는 PC에 라이선스를 설정한다. -> 자산은 어디에 설정할 것인가?
* 라이선스는 여러 자산을 보유한 조직에 속해 있다 -> 조직 정보는 어디에 저장할 것인가?
> 위에서 설명한 지침을 참고로 명사를 보면 테이블로 계약, 라이선스, 자산, 조직이 필요함을 알 수 있다.</br>
> 단순화된 O-stack 데이터 모델 그림 p102 참고</br>
> 조직은 많은 라이선스를 보유하고 라이선스는 하나 이상의 자산에 적용될 수 있고 각 라이선스에는 계약이 있다.
</br>
</br>
</br>

## 3.1.2 서비스 세분화 확정
> 데이터 모델 단순화 다음 과정으로 필요한 마이크로서비스 정의하는 과정
* 위에서 나온 주요 기능 부분(조직, 라이선스, 자산, 계약)을 서로 독립적으로 빌드하고 배포할 수 있는 완전한 자립형 유닛으로 추출해야 한다.
* 유닛은 각각 데이터베이스를 공유하거나 개별적으로 가질 수 있다.</br>

:star: 각 서비스는 해당 도메인 내에 모든 데이터를 소유한다. -> 모든 서비스는 자체 데이터베이스가 있다는 것이 아니라 해당 도메인을 소유한 서비스만 그 도메인의 데이터베이스에 접근할 수 있다는 의미
</br>

**마이크로서비스 세분화**
* 마이크로서비스는 광범위하게 시작하고 더 작은 서비스로 리팩터링하는 것이 좋다.
* 서비스 간 교류하는 방식에 중점을 둔다.
* 문제 도메인에 이해가 깊어지면서 서비스 책임도 계속 변한다.
  * 새로운 애플리케이션 기능이 요구되면 마이크로서비스는 그 책임을 맡는다.
</br>

**나쁜 마이크로서비스의 징후**
1. 너무 큰 마이크로서비스</br>

|종류|설명|
|:--|:--|
|책임이 너무 많은 서비스|해당 서비스에서 비즈니스 로직의 일반적 흐름이 복잡하고 지나치게 다양한 종류의 비즈니스 규칙을 시행하는 경우|
|다수 테이블에 거쳐 데이터를 관리하는 서비스|* 다수의 테이블에 데이터 유지 혹은 서비스의 데이터베이스 외부에 있는 테이블에 접근하는 경우</br> * 마이크로서비스는 자기가 관리하는 데이터베이스의 기록으로 3~5개 이하의 테이블 소유가 적당하다.|
|테스트가 너무 많은 서비스|서비스가 적은 수의 테스트 케이스로 시작해서 수백 개의 유닛 테스트와 통합 테스트로 끝나는 경우(서비스는 시간이 지나면서 규모와 책임이 더 커지기 때문에 주의)|
2. 너무 작은 마이크로서비스</br>

|종류|설명|
|:--|:--|
|문제 도메인의 한 부분에 속한 마이크로서비스가 토끼처럼 번식한다|* 모든 것이 마이크로서비스가 되면 서비스에서 비즈니스로직을 구성하는 것이 복잡하고 어려워진다.</br> * ex) 애플리테이션의 수십 개의 마이크로서비스가 존재하고 각 서비스가 하나의 데이터베이스 테이블과 통신하는 경우|
|마이크로서비스가 지나치게 상호의존적이다|문제 영역에 있는 마이크로서비스가 하나의 사용자 요청 완료를 위해 계속 서로 호출하는 경우|
|마이크로서비스가 단순한 CRUD 서비스 집합이 된다|마이크로서비스가 CRUD 관련 로직만 수행하고 있다면 너무 세분화된 경우일 수 있다.|
</br>
</br>
</br>

## 3.1.3 서비스 인터페이스 설계
> 아키텍처에 대한 마지막 조언은 애플리케이션 내 마이크로서비스들의 상호 통신 방식의 정의이다.</br>
> 비즈니스 로직 구축 시 서비스의 인터페이스의 직관적이어야 한다.</br>
> 개발자는 모든 서비스가 어떻게 동작하는지 규칙을 습득해야 한다.</br>

1. REST 철학을 수용하라
  * 표준 HTTP 동사(GET, PUT, POST, DELETE)를 사용하면서 서비스 호출 프로토콜로 HTTP를 수용하는 것
2. URI(서비스의 엔드포인트)를 사용하여 의도를 전달하라
3. 요청과 응답에 JSON을 사용하라
  * JSON은 총 경량 데이터 직렬화 프로토콜로 XML보다 사용하기 쉬움
4. HTTP 상태 코드를 결과를 전달하라


